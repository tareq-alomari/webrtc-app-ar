# تقرير فني: تطبيق مؤتمرات الفيديو عبر WebRTC

**تاريخ:** 25 مايو 2024

**إعداد:** علي القواس, حازم العمري, طارق العمري

**إشراف:** د. إياد المخلافي

---

## 1. مقدمة

هذا التقرير يقدم تحليلاً فنياً شاملاً لمشروع "تطبيق مؤتمرات الفيديو"، وهو نظام متكامل يتيح للمستخدمين التواصل الصوتي والمرئي في الوقت الفعلي عبر الويب. تم بناء المشروع باستخدام حزمة تقنيات حديثة ترتكز على **Node.js** في الخلفية و **JavaScript** مع **WebRTC** في الواجهة الأمامية.

يهدف المشروع إلى توفير منصة تواصل آمنة، تفاعلية، وسهلة الاستخدام، مع التركيز على الأداء والموثوقية.

---

## 2. بنية النظام (System Architecture)

يعتمد النظام على بنية **الخادم-العميل (Client-Server)** لعملية الإشارة (Signaling) وبنية **الند للند (Peer-to-Peer)** لتبادل الوسائط.

1.  **خادم الإشارة (Signaling Server):**

    - مبني باستخدام **Node.js** و **Express** مع مكتبة **`ws`** للـ **WebSocket**.
    - **مسؤولياته:**
      - إدارة المستخدمين المتصلين وتعيين معرفات فريدة لهم.
      - تنسيق عملية إنشاء الاتصال بين الأقران (Handshake) عبر تبادل رسائل SDP (Offer/Answer).
      - تبادل مرشحي ICE (ICE Candidates) للمساعدة في اختراق جدران الحماية (NAT Traversal).
      - إدارة منطق المكالمة مثل بدء المكالمة، طلبات الانضمام، صلاحيات المضيف، والدردشة.
      - إدارة المصادقة وجلسات المستخدمين.

2.  **العميل (Client):**
    - صفحة ويب تعمل على أي متصفح حديث.
    - **مسؤولياته:**
      - الوصول إلى كاميرا وميكروفون المستخدم (`getUserMedia`).
      - إنشاء اتصال WebSocket مع خادم الإشارة.
      - إنشاء كائنات `RTCPeerConnection` لكل مشارك آخر في المكالمة.
      - إرسال واستقبال رسائل الإشارة (SDP, ICE) عبر WebSocket.
      - بث الوسائط (الصوت والفيديو) مباشرة إلى الأقران الآخرين (P2P).
      - عرض التدفقات المرئية الواردة وإدارة واجهة المستخدم.

_رسم تخطيطي لبنية النظام_

---

## 3. التقنيات المستخدمة

- **الخادم (Backend):**

  - **Node.js / Express.js:** لتوفير واجهة برمجة تطبيقات RESTful بسيطة للمصادقة وخدمة الملفات الثابتة.
  - **WebSocket (`ws`):** لتوفير قناة اتصال منخفضة الكمون (low-latency) لتبادل رسائل الإشارة.
  - **bcrypt / express-session:** لتأمين المصادقة وإدارة جلسات المستخدم.

- **العميل (Frontend):**
  - **Vanilla JavaScript (ES6):** تم تنظيم الكود في أصناف (Classes) لتحقيق قابلية الصيانة والفصل بين المسؤوليات (`SessionManager`, `UIManager`, `NetworkClient`).
  - **WebRTC API:** هي التقنية الأساسية التي تتيح الاتصال المباشر بين المتصفحات.
  - **Bootstrap 5:** لتسريع تطوير واجهة مستخدم متجاوبة وجميلة.

---

## 4. تدفق عمل التطبيق (Application Workflow)

### أ. بدء المكالمة (Host)

1.  المستخدم الأول يسجل دخوله، يدخل اسمه، وينقر على "بدء مكالمة".
2.  العميل يطلب الوصول إلى الكاميرا والميكروفون.
3.  `SessionManager` يرسل رسالة `start-call` إلى خادم WebSocket.
4.  الخادم يعيّن هذا العميل كـ `hostId` وينشئ `callId` فريدًا للمكالمة.
5.  الخادم يرسل رسالة `set-host` إلى العميل، مؤكدًا دوره كمضيف.

### ب. الانضمام إلى مكالمة (Guest)

1.  مستخدم آخر (ضيف) يفتح رابط الدعوة أو الصفحة الرئيسية بعد تسجيل الدخول.
2.  يدخل اسمه وينقر على "الانضمام".
3.  `SessionManager` يرسل رسالة `request-to-join` مع `callId` (إن وجد).
4.  الخادم يستقبل الطلب ويوجهه إلى المضيف (`hostId`).
5.  واجهة المضيف تعرض طلب الانضمام مع أزرار "قبول" و "رفض".
6.  **في حالة القبول:**
    - المضيف يرسل `approve-join`.
    - الخادم يرسل رسالة `join-approved` إلى الضيف، مع قائمة بالمشاركين الحاليين.
    - الخادم يرسل رسالة `peer-joined` إلى جميع المشاركين الآخرين لإعلامهم بانضمام عضو جديد.
    - **يبدأ المضيف عملية اتصال WebRTC مع الضيف الجديد** عن طريق إرسال `offer`.
7.  **في حالة الرفض:**
    - المضيف يرسل `reject-join`.
    - الخادم يرسل `join-rejected` إلى الضيف، ويتم إغلاق نافذة الانتظار.

### ج. عملية اتصال WebRTC (Handshake)

1.  **الطرف المُبادر (Initiator - غالبًا المضيف أو المشارك الأقدم):**
    - ينشئ `RTCPeerConnection`.
    - ينشئ عرضًا (Offer) باستخدام `createOffer()`.
    - يضبط العرض كوصف محلي `setLocalDescription()`.
    - يرسل رسالة `offer` عبر WebSocket إلى الطرف الآخر.
2.  **الطرف المُستقبِل (Receiver):**
    - يستقبل الـ `offer`.
    - يضبطه كوصف بعيد `setRemoteDescription()`.
    - ينشئ إجابة (Answer) باستخدام `createAnswer()`.
    - يضبط الإجابة كوصف محلي `setLocalDescription()`.
    - يرسل رسالة `answer` عبر WebSocket إلى المُبادر.
3.  **المُبادر:** يستقبل الـ `answer` ويضبطه كوصف بعيد `setRemoteDescription()`.
4.  **تبادل مرشحي ICE:**
    - بمجرد تعيين الأوصاف، يبدأ كلا الطرفين في جمع مرشحي ICE (عناوين IP ومنافذ محتملة للاتصال).
    - عند العثور على مرشح، يتم إرساله إلى الطرف الآخر عبر رسالة `ice-candidate`.
    - يضيف كل طرف المرشحين الواردين باستخدام `addIceCandidate()`.
5.  عندما يجد الطرفان مسار اتصال صالحًا، يتم إنشاء الاتصال P2P، ويبدأ بث الوسائط مباشرة بينهما.

---

## 5. هيكلية الكود (Code Structure)

تم تصميم الكود الأمامي ليكون معياريًا وسهل الصيانة عبر فصل المسؤوليات إلى ثلاثة أصناف رئيسية:

- `main.js`: نقطة الدخول التي تهيئ التطبيق وتدير دورة حياته.
- `NetworkClient.js`: **طبقة الشبكة**. مسؤول حصريًا عن إدارة اتصال WebSocket، وإعادة الاتصال التلقائي، وإرسال واستقبال الرسائل من الخادم.
- `UIManager.js`: **طبقة العرض (View)**. مسؤول عن جميع التفاعلات مع DOM، مثل عرض الفيديوهات، تحديث الأزرار، عرض الرسائل، وإدارة النوافذ المنبثقة. لا يحتوي على أي منطق عمل (Business Logic).
- `SessionManager.js`: **طبقة منطق العمل (Controller/Logic)**. هو العقل المدبر الذي يربط بين جميع الأجزاء. يستمع إلى إجراءات المستخدم من `UIManager` ورسائل الشبكة من `NetworkClient`، ويدير حالة جلسة WebRTC، ويتخذ القرارات.

هذا الفصل يتبع مبدأ **فصل الاهتمامات (Separation of Concerns)**، مما يجعل الكود أكثر تنظيمًا وقابلية للاختبار والتطوير.

---

## 6. نقاط القوة والتحديات

### نقاط القوة

- **أداء عالي:** استخدام WebRTC للاتصال P2P يقلل من الحمل على الخادم ويقلل من زمن الوصول (latency).
- **قابلية التوسع:** يمكن للنظام دعم عدد كبير من المكالمات المتزامنة لأن الخادم يتعامل فقط مع الإشارة وليس مع الوسائط.
- **كود منظم:** الفصل الواضح بين المسؤوليات في الواجهة الأمامية يسهل الصيانة والتطوير المستقبلي.
- **ميزات غنية:** يوفر التطبيق ميزات متقدمة مثل الاستطلاعات والدردشة الخاصة التي لا توجد في العديد من التطبيقات الأساسية.

### التحديات والتحسينات المستقبلية

- **NAT Traversal:** قد يواجه الاتصال P2P صعوبة في اختراق بعض أنواع جدران الحماية المعقدة (Symmetric NAT). يمكن حل هذا عبر إضافة خادم **TURN** إلى إعدادات `RTCPeerConnection` لترحيل الوسائط عند فشل الاتصال المباشر.
- **قابلية التوسع للمكالمات الكبيرة:** في المكالمات التي تضم عددًا كبيرًا من المشاركين، يصبح نموذج P2P (Mesh) غير فعال لأن كل عميل يحتاج إلى إرسال واستقبال تدفقات من جميع المشاركين الآخرين. يمكن التحول إلى بنية **SFU (Selective Forwarding Unit)** مثل **Janus** أو **Mediasoup** لحل هذه المشكلة.
- **مشاركة الشاشة:** يمكن إضافة ميزة مشاركة الشاشة باستخدام `getDisplayMedia()`.
- **تسجيل المكالمات:** يمكن إضافة وظيفة لتسجيل المكالمات من جانب الخادم (يتطلب SFU/MCU).

---

## 7. خاتمة

يمثل هذا المشروع تطبيقًا عمليًا وقويًا لتقنية WebRTC، مع بنية مدروسة ومجموعة واسعة من الميزات. إنه يوفر أساسًا متينًا يمكن البناء عليه لإضافة المزيد من الوظائف المتقدمة في المستقبل، ويظهر فهمًا عميقًا لآلية عمل اتصالات الويب في الوقت الفعلي.
